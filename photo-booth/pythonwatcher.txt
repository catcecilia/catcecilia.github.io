import os
import tkinter as tk
from tkinter import filedialog
from PIL import Image, ImageTk
import qrcode
import cloudinary
import cloudinary.uploader
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time

# ---------- Cloudinary Signed Upload Config ----------
cloudinary.config(
    cloud_name='your_cloud_name',       # ← REPLACE
    api_key='your_api_key',             # ← REPLACE
    api_secret='your_api_secret'        # ← REPLACE
)

# ---------- Watchdog Event Handler ----------
class FolderWatcher(FileSystemEventHandler):
    def __init__(self, folder, on_new_file):
        self.folder = folder
        self.on_new_file = on_new_file

    def handle_file_event(self, path):
        if path.lower().endswith(('.png', '.gif')):
            self.on_new_file(path)

    def on_created(self, event):
        if not event.is_directory:
            self.handle_file_event(event.src_path)

    def on_moved(self, event):
        if not event.is_directory:
            self.handle_file_event(event.dest_path)

    def on_modified(self, event):
        if not event.is_directory:
            self.handle_file_event(event.src_path)


# ---------- QR App ----------
class QRApp:
    def __init__(self, root):
        self.root = root
        self.root.title("QR Display")
        self.root.geometry("400x400")
        self.root.configure(bg="white")

        self.folder = ''
        self.timer = None
        self.countdown_id = None

        self.init_screen1()
        self.init_screen2()

        self.show_screen1()

    # Screen 1: Folder Select
    def init_screen1(self):
        self.screen1 = tk.Frame(self.root, bg="white")
        self.select_btn = tk.Button(
            self.screen1,
            text="Select Folder to Watch",
            font=("Arial", 16),
            command=self.select_folder
        )
        self.select_btn.pack(expand=True)

    # Screen 2: QR Display
    def init_screen2(self):
        self.screen2 = tk.Frame(self.root, bg="white")
        self.qr_label = tk.Label(self.screen2, bg="white")
        self.qr_label.pack(expand=True)

        self.countdown_label = tk.Label(self.screen2, text="", font=("Arial", 12), bg="white")
        self.countdown_label.pack(pady=10)

    def show_screen1(self):
        self.screen2.pack_forget()
        self.screen1.pack(fill="both", expand=True)

    def show_screen2(self):
        self.screen1.pack_forget()
        self.screen2.pack(fill="both", expand=True)

    def select_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.folder = folder
            self.start_folder_watch()
            self.show_screen2()

    def start_folder_watch(self):
        self.event_handler = FolderWatcher(self.folder, self.handle_new_file)
        self.observer = Observer()
        self.observer.schedule(self.event_handler, self.folder, recursive=False)
        self.observer.start()

    def handle_new_file(self, filepath):
        print(f"Detected: {filepath}")
        self.clear_timer()

        # Wait until file is stable (not changing size)
        if self.wait_until_file_is_ready(filepath):
            url = self.upload_to_cloudinary(filepath)
            if url:
                self.display_qr_code(url)
                self.set_clear_timer()
        else:
            print(f"File {filepath} was not ready after timeout.")

    def wait_until_file_is_ready(self, filepath, timeout=10, interval=0.5):
        """Waits until file size stops changing (max timeout)."""
        previous_size = -1
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                current_size = os.path.getsize(filepath)
                if current_size == previous_size:
                    return True
                previous_size = current_size
            except OSError:
                pass  # File may not exist yet
            time.sleep(interval)
        return False

    # ✅ Cloudinary signed upload
    def upload_to_cloudinary(self, filepath):
        try:
            result = cloudinary.uploader.upload(filepath)
            return result.get("secure_url")
        except Exception as e:
            print("Upload failed:", e)
            return None

    def display_qr_code(self, url):
        qr = qrcode.make(url)
        qr = qr.resize((300, 300))
        qr_img = ImageTk.PhotoImage(qr)
        self.qr_label.config(image=qr_img)
        self.qr_label.image = qr_img

    def clear_qr_code(self):
        self.qr_label.config(image='')
        self.qr_label.image = None
        print("QR code cleared")

    def set_clear_timer(self):
        self.timer = self.root.after(30000, self.clear_qr_code)

    def clear_timer(self):
        if self.timer:
            self.root.after_cancel(self.timer)
            self.timer = None

    def start_countdown(self, seconds):
        self.update_countdown_label(seconds)

    def update_countdown_label(self, remaining):
        if remaining <= 0:
            self.countdown_label.config(text="")
            return
        self.countdown_label.config(text=f"QR expires in {remaining} seconds")
        self.countdown_id = self.root.after(1000, self.update_countdown_label, remaining - 1)

    def cancel_countdown(self):
        if self.countdown_id:
            self.root.after_cancel(self.countdown_id)
            self.countdown_id = None
            self.countdown_label.config(text="")
            
# ---------- Run App ----------
if __name__ == "__main__":
    root = tk.Tk()
    app = QRApp(root)
    try:
        root.mainloop()
    finally:
        if hasattr(app, 'observer'):
            app.observer.stop()
            app.observer.join()
